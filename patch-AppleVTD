1. Install IOKit private headers
2. Apply patch against IOPCIFamily-162.3 & build

--- IOPCIFamily.xcodeproj/project.pbxproj.orig	2012-10-24 23:14:56.000000000 +0400
+++ IOPCIFamily.xcodeproj/project.pbxproj	2012-10-26 03:30:23.000000000 +0400
@@ -107,6 +107,8 @@
 		03DB1085033AA50A03CA2A5F /* IOPCIBridge.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = IOPCIBridge.h; sourceTree = "<group>"; };
 		03DB1086033AA50A03CA2A5F /* IOPCIDevice.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = IOPCIDevice.h; sourceTree = "<group>"; };
 		1590524609368A190010639A /* IOPCIConfigurator.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIConfigurator.cpp; sourceTree = "<group>"; };
+		2152CDB616387A2F0056E691 /* vtd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = vtd.c; sourceTree = "<group>"; };
+		21EDF600163991BF001B5CF3 /* dmar.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = dmar.h; sourceTree = "<group>"; };
 		4094C51900CEE7A80ACA2928 /* IOPCIBridge.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIBridge.cpp; sourceTree = "<group>"; };
 		4094C51A00CEE7A80ACA2928 /* IOPCIDevice.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIDevice.cpp; sourceTree = "<group>"; };
 		4094C51B00CEE7A80ACA2928 /* IOPCIDeviceI386.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIDeviceI386.cpp; sourceTree = "<group>"; };
@@ -185,6 +187,8 @@
 				4094C51A00CEE7A80ACA2928 /* IOPCIDevice.cpp */,
 				4094C51B00CEE7A80ACA2928 /* IOPCIDeviceI386.cpp */,
 				A655D6E40E4BB51D00550BCC /* IOPCIDeviceMappedIO.cpp */,
+				2152CDB616387A2F0056E691 /* vtd.c */,
+				21EDF600163991BF001B5CF3 /* dmar.h */,
 				03DB1082033AA50A03CA2A5F /* IOKit */,
 			);
 			name = Source;
@@ -425,6 +429,7 @@
 		A613B2890D46AA65007BA726 /* Development */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ARCHS = "$(ONLY_ACTIVE_ARCH_PRE_XCODE_3_1)";
 				BUNDLE_STYLE = SHALLOW;
 				COPY_PHASE_STRIP = NO;
 				FRAMEWORK_SEARCH_PATHS = "";
@@ -444,6 +449,7 @@
 				MODULE_IOKIT = YES;
 				MODULE_NAME = com.apple.iokit.IOPCIFamily;
 				MODULE_VERSION = 2.4.1;
+				ONLY_ACTIVE_ARCH_PRE_XCODE_3_1 = "$(NATIVE_ARCH_64)";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = "";
 				OTHER_REZFLAGS = "";
--- IOPCIBridge.cpp.orig	2012-10-24 23:32:23.000000000 +0400
+++ IOPCIBridge.cpp	2012-10-26 04:33:01.000000000 +0400
@@ -855,10 +855,17 @@ IOReturn IOPCIBridge::configOp(IOService
         }
 
 #if ACPI_SUPPORT
+        /* Play safe for people with hackintoshes with enabled VT-d option */
+        if (IOService::getPlatform()->getProperty(kIOPlatformMapperPresentKey))
+        {
 		IOACPIPlatformDevice * acpiDevice;
 		if (!(acpiDevice = (typeof(acpiDevice)) device->getProvider()->metaCast("IOACPIPlatformDevice")))
             panic("host!IOACPIPlatformDevice");
 		AppleVTD::install(gIOPCIConfigWorkLoop, gIOPCIFlags, acpiDevice, acpiDevice->getACPITableData("DMAR", 0));
+        }
+        else {
+            IOLog("Wanna try VT-d? Pass dart=1 parameter to kernel.\n");
+        }
 #endif
     }
 
--- dmar.h.orig	2012-10-28 11:19:43.000000000 +0400
+++ dmar.h	2012-10-28 11:19:51.000000000 +0400
@@ -103,6 +103,8 @@ typedef struct acpi_dmar_pci_path
 
 } ACPI_DMAR_PCI_PATH;
 
+#define MIN_SCOPE_LEN (sizeof(struct acpi_dmar_device_scope) + \
+sizeof(struct acpi_dmar_pci_path))
 
 /*
  * DMAR Sub-tables, correspond to Type in ACPI_DMAR_HEADER
--- vtd.c.orig	2012-10-26 05:15:48.000000000 +0400
+++ vtd.c	2012-10-29 22:03:32.000000000 +0400
@@ -24,6 +24,7 @@
 
 #include <IOKit/IOMapper.h>
 #include <IOKit/IOKitKeysPrivate.h>
+#include <IOKit/acpi/IOACPITypes.h>
 #include <libkern/tree.h>
 #include <libkern/OSDebug.h>
 #include <i386/cpuid.h>
@@ -36,7 +37,9 @@ extern "C" ppnum_t pmap_find_phys(pmap_t
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
-#define ENA_QI			1
+#define WA_BBUG         1
+//#define INCL_MAP
+
 #define TABLE_CB		0
 #define BSIMPLE			0
 
@@ -55,10 +58,10 @@ extern "C" ppnum_t pmap_find_phys(pmap_t
 
 #define VTLOG(fmt, args...)                   \
     do {                                                    						\
-        if ((gIOPCIFlags & kIOPCIConfiguratorVTLog) && !ml_at_interrupt_context())  \
+        if (/*(gIOPCIFlags & kIOPCIConfiguratorVTLog) &&*/ !ml_at_interrupt_context())  \
             IOLog(fmt, ## args);                           							\
-        if (gIOPCIFlags & kIOPCIConfiguratorVTLog)        							\
-            kprintf(fmt, ## args);                          						\
+        /*if (gIOPCIFlags & kIOPCIConfiguratorVTLog)*/        							\
+            /*kprintf(fmt, ## args);*/                          						\
     } while(0)
 
 
@@ -156,6 +159,14 @@ enum
 	kTheDomain    = 2ULL
 };
 
+/* Device features */
+typedef struct {
+    bool qi; /* Queued Invalidation */
+    //bool sc; /* Snoop Control */
+    //bool dp; /* DMA Passthrough */
+    //bool ir; /* Interrupt Remapping */
+} features;
+
 typedef uint64_t page_entry_t;
 
 // page_entry_t
@@ -280,52 +291,6 @@ static inline void clflush(uintptr_t add
 	__mfence();
 }
 
-static
-vtd_unit_t * unit_init(ACPI_DMAR_HARDWARE_UNIT * dmar)
-{
-	vtd_unit_t * unit;
-
-	unit = IONew(vtd_unit_t, 1);
-	if (!unit) return (NULL);
-	bzero(unit, sizeof(vtd_unit_t));
-
-	unit->dmar = dmar;
-
-	VTLOG("unit %p Address %llx, Flags %x\n",
-			dmar, dmar->Address, dmar->Flags);
-
-	unit->regs = (typeof unit->regs) ml_io_map(dmar->Address, 0x1000);
-
-	uint32_t
-	offset = (unit->regs->extended_capability >> (8 - 4)) & (((1 << 10) - 1) << 4);
-	unit->iotlb = (typeof(unit->iotlb)) (((uintptr_t)unit->regs) + offset);
-
-	offset = (unit->regs->capability >> (24 - 4)) & (((1 << 10) - 1) << 4);
-	unit->faults = (typeof(unit->faults)) (((uintptr_t)unit->regs) + offset);
-	unit->num_fault = (1 + ((unit->regs->capability >> 40) & ((1 << 8) - 1)));
-
-	unit->selective = (1 & (unit->regs->capability >> 39));
-	unit->rounding = (0x3f & (unit->regs->capability >> 48));
-	unit->caching = (1 & (unit->regs->capability >> 7));
-	unit->global = (ACPI_DMAR_INCLUDE_ALL & dmar->Flags);
-
-	VTLOG("cap 0x%llx extcap 0x%llx glob %d cache sel %d mode %d iotlb %p nfault[%d] %p\n", 
-			unit->regs->capability, unit->regs->extended_capability,
-			unit->global, unit->selective, unit->caching, 
-			unit->iotlb, unit->num_fault, unit->faults);
-
-	// caching is only allowed for VMs
-	if (unit->caching
-	// disable IG unit
-	|| ((!unit->global) && (!(kIOPCIConfiguratorIGIsMapped & gIOPCIFlags))))
-	{
-		IODelete(unit, vtd_unit_t, 1);
-		unit = NULL;
-	}
-	
-	return (unit);
-}
-
 static void 
 unit_faults(vtd_unit_t * unit, bool log)
 {
@@ -355,7 +320,7 @@ unit_faults(vtd_unit_t * unit, bool log)
 }
 
 static void 
-unit_enable(vtd_unit_t * unit)
+unit_enable(vtd_unit_t * unit, features *fs)
 {
     uint32_t command;
 
@@ -387,13 +352,13 @@ unit_enable(vtd_unit_t * unit)
 
 	command = 0;
 
-#if ENA_QI
+    if (fs->qi) {
 	command |= (1UL<<26);
 	unit->regs->global_command = command;
 	__mfence();
 	while (!((1UL<<26) & unit->regs->global_status)) {}
 	VTLOG("did ena qi p 0x%qx v %p\n", unit->qi_address, unit->qi_table);
-#endif
+    }
 
 	command |= (1UL<<31);
 	unit->regs->global_command = command;
@@ -733,9 +698,11 @@ public:
 	IOInterruptEventSource * fIntES;
 	IOInterruptEventSource * fFaultES;
     IOTimerEventSource     * fTimerES;
+    IOACPIPlatformDevice   * provider;
 
 	enum { kMaxUnits = 8 };
 	vtd_unit_t * units[kMaxUnits];
+    features fs;
 
 	uint32_t fTreeBits;
 	uint32_t fMaxRoundSize;
@@ -793,6 +760,9 @@ public:
 				  const IODMAMapSpecification * mapSpecification);
 
     virtual addr64_t mapAddr(IOPhysicalAddress addr);
+    vtd_unit_t * unit_init(ACPI_DMAR_HARDWARE_UNIT *);
+    int parse_dev_scope(const void *, const void *, UInt16, UInt16);
+    UInt32 configRead16(UInt32 seg, UInt32 bus, UInt32 dev, UInt32 func, UInt32 off);
 };
 
 
@@ -808,14 +778,13 @@ AppleVTD::install(IOWorkLoop * wl, uint3
 	AppleVTD * mapper = 0;
 	bool ok = false;
 
-	if (!IOService::getPlatform()->getProperty(kIOPlatformMapperPresentKey)) return;
-
 	VTLOG("DMAR %p\n", data);
 	if (data) 
 	{
 		mapper = new AppleVTD;
 		if (mapper)
 		{
+            mapper->provider = (typeof(mapper->provider)) provider;
 			if (mapper->init(wl, data) && mapper->attach(provider))
 			{
 				ok = mapper->start(provider);
@@ -843,6 +812,7 @@ AppleVTD::init(IOWorkLoop * wl, const OS
 	wl->retain();
 	fWorkLoop = wl;
 	fCacheLineSize = cpuid_info()->cache_linesize;
+    fs.qi = true;
 
 	ACPI_TABLE_DMAR *           dmar = (typeof(dmar))      data->getBytesNoCopy();
 	ACPI_DMAR_HEADER *          dmarEnd = (typeof(dmarEnd))(((uintptr_t) dmar) + data->getLength());
@@ -862,6 +832,8 @@ AppleVTD::init(IOWorkLoop * wl, const OS
 				break;
 		}
 	}
+    
+    VTLOG("Queued Invalidation feature: %d\n", fs.qi);
 
 	return (unitIdx != 0);
 }
@@ -1225,6 +1197,10 @@ AppleVTD::initHardware(IOService *provid
 				mem = (typeof(mem)) hdr;
 				VTLOG("ACPI_DMAR_TYPE_RESERVED_MEMORY 0x%llx, 0x%llx\n", 
 					mem->BaseAddress, mem->EndAddress);
+                
+                if (parse_dev_scope((void *) (mem + 1), ((char *) mem) + mem->Header.Length, mem->Segment,
+                                    hdr->Type))
+                    continue;
 
 				addr = mem->BaseAddress;
 				count = atop_32(mem->EndAddress - addr);
@@ -1322,6 +1298,9 @@ AppleVTD::initHardware(IOService *provid
     }
 
 	//
+    
+    /* XXX: broken, do { iovmMapMemory(); iovmFree(); } while (true);  */
+    return false;
 
 	IOReturn  ret;
 	uint64_t  msiAddress;
@@ -1357,11 +1336,11 @@ AppleVTD::initHardware(IOService *provid
 	{
 		unit->msi_data    = msiData & 0xff;
 		unit->msi_address = msiAddress;
-		unit_enable(unit);
+		unit_enable(unit, &fs);
 	}
 	if (fIntES)   fIntES->enable();
 	if (fFaultES) fFaultES->enable();
-	
+
 //	fTimerES->setTimeoutMS(10);
 
 	setProperty(kIOPlatformQuiesceActionKey, INT32_MAX - 1000, 64);
@@ -1428,7 +1407,7 @@ AppleVTD::callPlatformFunction(const OSS
 		{
 			for (idx = 0; (unit = units[idx]); idx++) 
 			{
-				unit_enable(unit);
+				unit_enable(unit, &fs);
 			}
 			return (kIOReturnSuccess);
 		}
@@ -1552,14 +1531,14 @@ AppleVTD::iovmFree(ppnum_t addr, IOItemC
 	bzero(&fSpace->tables[0][addr], pages * sizeof(vtd_table_entry_t));
 	table_flush(&fSpace->tables[0][addr], pages * sizeof(vtd_table_entry_t), fCacheLineSize);
 
-#if !ENA_QI
+    if (!fs.qi) {
 	IOSimpleLockLock(fHWLock);
     iovmInvalidateSync(addr, pages);
 	IOSimpleLockUnlock(fHWLock);
 	space_free(fSpace, addr, pages);
 	return;
 
-#else	/* !ENA_QI */
+    } else { /* ENA_QI */
 
 	leaf = true;
 	isLarge = (addr >= fSpace->rsize);
@@ -1641,7 +1620,7 @@ AppleVTD::iovmFree(ppnum_t addr, IOItemC
 
 	IOSimpleLockUnlock(fHWLock);
 
-#endif /* ENA_QI */
+    } /* ENA_QI */
 }
 
 #define stampPassed(a,b)	(((int32_t)((a)-(b))) >= 0)
@@ -1769,5 +1748,130 @@ AppleVTD::iovmInsert(ppnum_t addr, IOIte
 	STAT_ADD(fSpace, inserts, pageCount);
 }
 
+UInt32 AppleVTD::configRead16(UInt32 seg, UInt32 bus, UInt32 dev, UInt32 func, UInt32 off)
+{
+    IOACPIAddress address;
+    UInt64 value;
+    
+    address.pci.segment = seg;
+    address.pci.bus = bus;
+    address.pci.device = dev;
+    address.pci.function = func;
+    address.pci.offset = off;
+    address.pci.reserved = 0;
+    value = -1ULL;
+    
+    provider->readAddressSpace(&value, kIOACPIAddressSpaceIDPCIConfiguration, address, 16);
+    
+    return value;
+}
+
+int AppleVTD::parse_dev_scope(const void *start, const void *end, UInt16 seg, UInt16 type)
+{
+    const ACPI_DMAR_DEVICE_SCOPE *scope;
+    ACPI_DMAR_PCI_PATH *path;
+    UInt16 vend;
+    int count = 0, fault = 0;
+    
+    while (start < end) {
+        scope = (typeof(scope)) start;
+        path = (typeof(path)) (scope + 1);
+        
+        if ( (scope->Length < MIN_SCOPE_LEN) ||
+            (scope->EntryType >= ACPI_DMAR_SCOPE_TYPE_RESERVED) ) {
+            VTLOG("Invalid device scope\n");
+            return 1;
+        }
+        
+        if (scope->EntryType == ACPI_DMAR_SCOPE_TYPE_ENDPOINT) {
+            vend = configRead16(seg, scope->Bus, path->Device, path->Function, 0);
+            if ((vend == 0xffff) || (vend == 0x0000) || (vend == 0x00ff) || (vend == 0xff00)) {
+                IOLog("Non-existent device %04x:%02x:%02x.%u is reported\n",
+                      seg, scope->Bus, path->Device, path->Function);
+                fault++;
+            } else
+            // disable IG unit
+            if (type == ACPI_DMAR_TYPE_HARDWARE_UNIT)
+                if ((seg == 0) && (scope->Bus == 0) && (path->Device == 2) && (path->Function == 0))
+                    return 1;
+            count++;
+        }
+        
+        start = ((char *) start) + scope->Length;
+    }
+    
+    if (count == 0) {
+        /*if (!unit->global)
+            VTLOG("No devices found under the scope\n");*/
+        if (type == ACPI_DMAR_TYPE_RESERVED_MEMORY)
+            return 1;
+    }
+    else if (count == fault) {
+        if (type == ACPI_DMAR_TYPE_HARDWARE_UNIT) {
+#if WA_BBUG
+            IOLog("Workaround BIOS bug: ignore the unit due to all devices under it's scope aren't"
+              " PCI discoverable\n");
+            return 1;
+#endif
+            ;
+        } else {
+            IOLog("Ignore the reserved region due to all devices under it's scope aren't"
+                  " PCI discoverable\n");
+            return 1;
+        }
+    }
+    
+    return 0;
+}
+
+vtd_unit_t * AppleVTD::unit_init(ACPI_DMAR_HARDWARE_UNIT * dmar)
+{
+	vtd_unit_t * unit;
+    
+	unit = IONew(vtd_unit_t, 1);
+	if (!unit) return (NULL);
+	bzero(unit, sizeof(vtd_unit_t));
+    
+	unit->dmar = dmar;
+    
+	VTLOG("unit %p Address %llx, Flags %x\n",
+          dmar, dmar->Address, dmar->Flags);
+    
+	unit->regs = (typeof unit->regs) ml_io_map(dmar->Address, 0x1000);
+    
+    /* Allows to boot for ones without this feature */
+    if (fs.qi && !((unit->regs->extended_capability >> 1) & 0x1))
+        fs.qi = false;
+    
+	uint32_t
+	offset = (unit->regs->extended_capability >> (8 - 4)) & (((1 << 10) - 1) << 4);
+	unit->iotlb = (typeof(unit->iotlb)) (((uintptr_t)unit->regs) + offset);
+    
+	offset = (unit->regs->capability >> (24 - 4)) & (((1 << 10) - 1) << 4);
+	unit->faults = (typeof(unit->faults)) (((uintptr_t)unit->regs) + offset);
+	unit->num_fault = (1 + ((unit->regs->capability >> 40) & ((1 << 8) - 1)));
+    
+	unit->selective = (1 & (unit->regs->capability >> 39));
+	unit->rounding = (0x3f & (unit->regs->capability >> 48));
+	unit->caching = (1 & (unit->regs->capability >> 7));
+	unit->global = (ACPI_DMAR_INCLUDE_ALL & dmar->Flags);
+    
+	VTLOG("cap 0x%llx extcap 0x%llx glob %d cache sel %d mode %d iotlb %p nfault[%d] %p\n",
+          unit->regs->capability, unit->regs->extended_capability,
+          unit->global, unit->selective, unit->caching,
+          unit->iotlb, unit->num_fault, unit->faults);
+
+	// caching is only allowed for VMs
+	if (unit->caching
+        || parse_dev_scope((void *) (dmar + 1), ((char *) dmar) + dmar->Header.Length, dmar->Segment,
+                           ACPI_DMAR_TYPE_HARDWARE_UNIT))
+	{
+		IODelete(unit, vtd_unit_t, 1);
+		unit = NULL;
+	}
+	
+	return (unit);
+}
+
 #endif /* ACPI_SUPPORT */
 
