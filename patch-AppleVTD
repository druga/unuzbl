Attempt to fix AppleVTD
What i do here:
1. Ask for Queued Invalidation feature support from hardware
2. Handle broken BIOSes, which report undiscoverable PCI devices in their DMAR
3. Do verbose output on failings
How to use:
1. Install IOKit private headers
2. Apply patch against IOPCIFamily-162.3 & build

--- IOPCIFamily.xcodeproj/project.pbxproj.orig	2012-10-24 23:14:56.000000000 +0400
+++ IOPCIFamily.xcodeproj/project.pbxproj	2012-10-26 03:30:23.000000000 +0400
@@ -107,6 +107,8 @@
 		03DB1085033AA50A03CA2A5F /* IOPCIBridge.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = IOPCIBridge.h; sourceTree = "<group>"; };
 		03DB1086033AA50A03CA2A5F /* IOPCIDevice.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = IOPCIDevice.h; sourceTree = "<group>"; };
 		1590524609368A190010639A /* IOPCIConfigurator.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIConfigurator.cpp; sourceTree = "<group>"; };
+		2152CDB616387A2F0056E691 /* vtd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = vtd.c; sourceTree = "<group>"; };
+		21EDF600163991BF001B5CF3 /* dmar.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = dmar.h; sourceTree = "<group>"; };
 		4094C51900CEE7A80ACA2928 /* IOPCIBridge.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIBridge.cpp; sourceTree = "<group>"; };
 		4094C51A00CEE7A80ACA2928 /* IOPCIDevice.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIDevice.cpp; sourceTree = "<group>"; };
 		4094C51B00CEE7A80ACA2928 /* IOPCIDeviceI386.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = IOPCIDeviceI386.cpp; sourceTree = "<group>"; };
@@ -185,6 +187,8 @@
 				4094C51A00CEE7A80ACA2928 /* IOPCIDevice.cpp */,
 				4094C51B00CEE7A80ACA2928 /* IOPCIDeviceI386.cpp */,
 				A655D6E40E4BB51D00550BCC /* IOPCIDeviceMappedIO.cpp */,
+				2152CDB616387A2F0056E691 /* vtd.c */,
+				21EDF600163991BF001B5CF3 /* dmar.h */,
 				03DB1082033AA50A03CA2A5F /* IOKit */,
 			);
 			name = Source;
@@ -425,6 +429,7 @@
 		A613B2890D46AA65007BA726 /* Development */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ARCHS = "$(ONLY_ACTIVE_ARCH_PRE_XCODE_3_1)";
 				BUNDLE_STYLE = SHALLOW;
 				COPY_PHASE_STRIP = NO;
 				FRAMEWORK_SEARCH_PATHS = "";
@@ -444,6 +449,7 @@
 				MODULE_IOKIT = YES;
 				MODULE_NAME = com.apple.iokit.IOPCIFamily;
 				MODULE_VERSION = 2.4.1;
+				ONLY_ACTIVE_ARCH_PRE_XCODE_3_1 = "$(NATIVE_ARCH_64)";
 				OTHER_CFLAGS = "";
 				OTHER_LDFLAGS = "";
 				OTHER_REZFLAGS = "";
--- dmar.h.orig	2012-10-28 11:19:43.000000000 +0400
+++ dmar.h	2012-10-28 11:19:51.000000000 +0400
@@ -103,6 +103,8 @@ typedef struct acpi_dmar_pci_path
 
 } ACPI_DMAR_PCI_PATH;
 
+#define MIN_SCOPE_LEN (sizeof(struct acpi_dmar_device_scope) + \
+sizeof(struct acpi_dmar_pci_path))
 
 /*
  * DMAR Sub-tables, correspond to Type in ACPI_DMAR_HEADER  
--- vtd.c.orig	2013-01-16 14:51:34.000000000 +0400
+++ vtd.c	2013-01-19 11:39:21.000000000 +0400
@@ -24,6 +24,7 @@
 
 #include <IOKit/IOMapper.h>
 #include <IOKit/IOKitKeysPrivate.h>
+#include <IOKit/acpi/IOACPITypes.h>
 #include <libkern/tree.h>
 #include <libkern/OSDebug.h>
 #include <i386/cpuid.h>
@@ -36,7 +37,9 @@ extern "C" ppnum_t pmap_find_phys(pmap_t
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
-#define ENA_QI			1
+#define WA_BBUG         1
+//#define INCL_MAP
+
 #define TABLE_CB		0
 #define BSIMPLE			0
 
@@ -53,11 +56,12 @@ extern "C" ppnum_t pmap_find_phys(pmap_t
 #define kTlbDrainReads  (0ULL)
 #define kTlbDrainWrites (0ULL)
 
+#define IOPrint(arg...) IOLog("AppleVTD: " arg)
 #define VTLOG(fmt, args...)                   \
     do {                                                    						\
-        if ((gIOPCIFlags & kIOPCIConfiguratorVTLog) && !ml_at_interrupt_context())  \
+        if (/*(gIOPCIFlags & kIOPCIConfiguratorVTLog) &&*/ !ml_at_interrupt_context())  \
             IOLog(fmt, ## args);                           							\
-        if (gIOPCIFlags & kIOPCIConfiguratorVTLog)        							\
+        if (/*gIOPCIFlags & kIOPCIConfiguratorVTLog*/1)        							\
             kprintf(fmt, ## args);                          						\
     } while(0)
 
@@ -67,14 +71,11 @@ extern "C" ppnum_t pmap_find_phys(pmap_t
 #define vtassert(ex)  \
 	((ex) ? (void)0 : Assert(__FILE__, __LINE__, # ex))
 
-#define vtd_space_nfault(x,y,z) _vtd_space_nfault(x,y,z)
-
 #define STAT_ADD(space, name, value) do { space->stats.name += value; } while (false);
 
 #else	/* VTASRT */
 
-#define vtassert(ex)  
-#define vtd_space_nfault(x,y,z)
+#define vtassert(ex)
 
 #define STAT_ADD(space, name, value) do { space->stats.name += value; } while (false);
 //#define STAT_ADD(space, name, value)
@@ -156,6 +157,16 @@ enum
 	kTheDomain    = 2ULL
 };
 
+/* Device features */
+typedef struct {
+    bool qi; /* Queued Invalidation */
+#if 0
+    bool sc; /* Snoop Control */
+    bool dp; /* DMA Passthrough */
+    bool ir; /* Interrupt Remapping */
+#endif
+} features;
+
 typedef uint64_t page_entry_t;
 
 // page_entry_t
@@ -280,52 +291,6 @@ static inline void clflush(uintptr_t add
 	__mfence();
 }
 
-static
-vtd_unit_t * unit_init(ACPI_DMAR_HARDWARE_UNIT * dmar)
-{
-	vtd_unit_t * unit;
-
-	unit = IONew(vtd_unit_t, 1);
-	if (!unit) return (NULL);
-	bzero(unit, sizeof(vtd_unit_t));
-
-	unit->dmar = dmar;
-
-	VTLOG("unit %p Address %llx, Flags %x\n",
-			dmar, dmar->Address, dmar->Flags);
-
-	unit->regs = (typeof unit->regs) ml_io_map(dmar->Address, 0x1000);
-
-	uint32_t
-	offset = (unit->regs->extended_capability >> (8 - 4)) & (((1 << 10) - 1) << 4);
-	unit->iotlb = (typeof(unit->iotlb)) (((uintptr_t)unit->regs) + offset);
-
-	offset = (unit->regs->capability >> (24 - 4)) & (((1 << 10) - 1) << 4);
-	unit->faults = (typeof(unit->faults)) (((uintptr_t)unit->regs) + offset);
-	unit->num_fault = (1 + ((unit->regs->capability >> 40) & ((1 << 8) - 1)));
-
-	unit->selective = (1 & (unit->regs->capability >> 39));
-	unit->rounding = (0x3f & (unit->regs->capability >> 48));
-	unit->caching = (1 & (unit->regs->capability >> 7));
-	unit->global = (ACPI_DMAR_INCLUDE_ALL & dmar->Flags);
-
-	VTLOG("cap 0x%llx extcap 0x%llx glob %d cache sel %d mode %d iotlb %p nfault[%d] %p\n", 
-			unit->regs->capability, unit->regs->extended_capability,
-			unit->global, unit->selective, unit->caching, 
-			unit->iotlb, unit->num_fault, unit->faults);
-
-	// caching is only allowed for VMs
-	if (unit->caching
-	// disable IG unit
-	|| ((!unit->global) && (!(kIOPCIConfiguratorIGIsMapped & gIOPCIFlags))))
-	{
-		IODelete(unit, vtd_unit_t, 1);
-		unit = NULL;
-	}
-	
-	return (unit);
-}
-
 static void 
 unit_faults(vtd_unit_t * unit, bool log)
 {
@@ -355,7 +320,7 @@ unit_faults(vtd_unit_t * unit, bool log)
 }
 
 static void 
-unit_enable(vtd_unit_t * unit)
+unit_enable(vtd_unit_t * unit, features *fs)
 {
     uint32_t command;
 
@@ -387,13 +352,13 @@ unit_enable(vtd_unit_t * unit)
 
 	command = 0;
 
-#if ENA_QI
+    if (fs->qi) {
 	command |= (1UL<<26);
 	unit->regs->global_command = command;
 	__mfence();
 	while (!((1UL<<26) & unit->regs->global_status)) {}
 	VTLOG("did ena qi p 0x%qx v %p\n", unit->qi_address, unit->qi_table);
-#endif
+    }
 
 	command |= (1UL<<31);
 	unit->regs->global_command = command;
@@ -568,11 +533,12 @@ vtd_log2down(vtd_vaddr_t size)
 }
 
 static void
-_vtd_space_nfault(vtd_space_t * bf, vtd_vaddr_t start, vtd_vaddr_t size)
+vtd_space_nfault(vtd_space_t * bf, vtd_vaddr_t start, vtd_vaddr_t size)
 {
-	vtd_vaddr_t index;
+	vtd_vaddr_t index, end;
 	vtd_vaddr_t byte;
 	uint8_t bit;
+    bool first_pass = true, map_flag;
 
 	vtassert((start + size) < bf->vsize);
 
@@ -584,8 +550,21 @@ _vtd_space_nfault(vtd_space_t * bf, vtd_
 		index = (start >> 9);
 		byte = (index >> 3);
 		bit = (1 << (7 & index));
-		vtassert(bf->table_bitmap[byte] & bit);
-		if (size < 512) break;
+        map_flag = bf->table_bitmap[byte] & bit;
+        if (!map_flag) {
+            if (first_pass) {
+                IOPrint("vtd: space isn't allocated for 0x%x", start);
+                first_pass = false;
+            }
+            end = start;
+        }
+		if (size < 512) {
+            if (!map_flag) {
+                IOLog(/*" - 0x%x*/" pg\n" /*, (int) ptoa_64(end)*/);
+                vtassert(map_flag);
+            }
+            break;
+        }
 		size -= 512;
 		start += 512;
 	}
@@ -733,9 +712,12 @@ public:
 	IOInterruptEventSource * fIntES;
 	IOInterruptEventSource * fFaultES;
     IOTimerEventSource     * fTimerES;
+    IOACPIPlatformDevice   * provider;
 
 	enum { kMaxUnits = 8 };
 	vtd_unit_t * units[kMaxUnits];
+    bool include_all_found;
+    features fs;
 
 	uint32_t fTreeBits;
 	uint32_t fMaxRoundSize;
@@ -793,6 +775,9 @@ public:
 				  const IODMAMapSpecification * mapSpecification);
 
     virtual addr64_t mapAddr(IOPhysicalAddress addr);
+    vtd_unit_t * unit_init(ACPI_DMAR_HARDWARE_UNIT *);
+    bool parse_dev_scope(const void *, const void *, UInt16, UInt16);
+    UInt32 configRead16(UInt32 seg, UInt32 bus, UInt32 dev, UInt32 func, UInt32 off);
 };
 
 
@@ -807,8 +792,8 @@ AppleVTD::install(IOWorkLoop * wl, uint3
 {
 	AppleVTD * mapper = 0;
 	bool ok = false;
-
-	if (!IOService::getPlatform()->getProperty(kIOPlatformMapperPresentKey)) return;
+    
+    if (!IOService::getPlatform()->getProperty(kIOPlatformMapperPresentKey)) return;
 
 	VTLOG("DMAR %p\n", data);
 	if (data) 
@@ -816,6 +801,7 @@ AppleVTD::install(IOWorkLoop * wl, uint3
 		mapper = new AppleVTD;
 		if (mapper)
 		{
+            mapper->provider = (typeof(mapper->provider)) provider;
 			if (mapper->init(wl, data) && mapper->attach(provider))
 			{
 				ok = mapper->start(provider);
@@ -843,6 +829,8 @@ AppleVTD::init(IOWorkLoop * wl, const OS
 	wl->retain();
 	fWorkLoop = wl;
 	fCacheLineSize = cpuid_info()->cache_linesize;
+    include_all_found = false;
+    fs.qi = true;
 
 	ACPI_TABLE_DMAR *           dmar = (typeof(dmar))      data->getBytesNoCopy();
 	ACPI_DMAR_HEADER *          dmarEnd = (typeof(dmarEnd))(((uintptr_t) dmar) + data->getLength());
@@ -862,6 +850,8 @@ AppleVTD::init(IOWorkLoop * wl, const OS
 				break;
 		}
 	}
+    
+    IOPrint("Queued Invalidation feature: %d\n", fs.qi);
 
 	return (unitIdx != 0);
 }
@@ -1031,6 +1021,8 @@ AppleVTD::space_alloc(vtd_space_t * bf, 
     vtd_vaddr_t align = 1;
     bool        uselarge;
 	uint32_t    list;
+    AbsoluteTime deadline;
+    int ret;
 
 	if ((kIODMAMapPagingPath & mapOptions) && (size > bf->stats.largest_paging))
 		bf->stats.largest_paging = size;
@@ -1090,12 +1082,15 @@ AppleVTD::space_alloc(vtd_space_t * bf, 
 			BUNLOCK(bf->block);
 		}
 		if (addr) break;
+        clock_interval_to_deadline(100, kMillisecondScale, &deadline);
 		IOLockLock(bf->rlock);
 		bf->waiting_space = true;
-		IOLockSleep(bf->rlock, &bf->waiting_space, THREAD_UNINT);
+		ret = IOLockSleepDeadline(bf->rlock, &bf->waiting_space, deadline, THREAD_INTERRUPTIBLE);
 		IOLockUnlock(bf->rlock);
-		IOLog("AppleVTD: waiting space (%d)\n", size);
-		VTLOG("AppleVTD: waiting space (%d)\n", size);
+        if (ret != THREAD_AWAKENED) {
+            IOPrint("waiting space (%d) timeout\n", size);
+            return 0x0;
+        }
 	}
 	while (true);
 
@@ -1217,14 +1212,18 @@ AppleVTD::initHardware(IOService *provid
 	for (; hdr < dmarEnd;
 			hdr = (typeof(hdr))(((uintptr_t) hdr) + hdr->Length))
 	{
-		uint64_t addr;
-		uint32_t count;
+               uint64_t addr;
+               uint32_t count;
 		switch (hdr->Type)
 		{
 			case ACPI_DMAR_TYPE_RESERVED_MEMORY:
 				mem = (typeof(mem)) hdr;
 				VTLOG("ACPI_DMAR_TYPE_RESERVED_MEMORY 0x%llx, 0x%llx\n", 
 					mem->BaseAddress, mem->EndAddress);
+                
+                if (!parse_dev_scope((void *) (mem + 1), ((char *) mem) + mem->Header.Length, mem->Segment,
+                                    hdr->Type))
+                    continue;
 
 				addr = mem->BaseAddress;
 				count = atop_32(mem->EndAddress - addr);
@@ -1357,11 +1356,11 @@ AppleVTD::initHardware(IOService *provid
 	{
 		unit->msi_data    = msiData & 0xff;
 		unit->msi_address = msiAddress;
-		unit_enable(unit);
+		unit_enable(unit, &fs);
 	}
 	if (fIntES)   fIntES->enable();
 	if (fFaultES) fFaultES->enable();
-	
+
 //	fTimerES->setTimeoutMS(10);
 
 	setProperty(kIOPlatformQuiesceActionKey, INT32_MAX - 1000, 64);
@@ -1428,7 +1427,7 @@ AppleVTD::callPlatformFunction(const OSS
 		{
 			for (idx = 0; (unit = units[idx]); idx++) 
 			{
-				unit_enable(unit);
+				unit_enable(unit, &fs);
 			}
 			return (kIOReturnSuccess);
 		}
@@ -1552,14 +1551,14 @@ AppleVTD::iovmFree(ppnum_t addr, IOItemC
 	bzero(&fSpace->tables[0][addr], pages * sizeof(vtd_table_entry_t));
 	table_flush(&fSpace->tables[0][addr], pages * sizeof(vtd_table_entry_t), fCacheLineSize);
 
-#if !ENA_QI
+    if (!fs.qi) {
 	IOSimpleLockLock(fHWLock);
     iovmInvalidateSync(addr, pages);
 	IOSimpleLockUnlock(fHWLock);
 	space_free(fSpace, addr, pages);
 	return;
 
-#else	/* !ENA_QI */
+    } else { /* ENA_QI */
 
 	leaf = true;
 	isLarge = (addr >= fSpace->rsize);
@@ -1641,7 +1640,7 @@ AppleVTD::iovmFree(ppnum_t addr, IOItemC
 
 	IOSimpleLockUnlock(fHWLock);
 
-#endif /* ENA_QI */
+    } /* ENA_QI */
 }
 
 #define stampPassed(a,b)	(((int32_t)((a)-(b))) >= 0)
@@ -1769,5 +1768,134 @@ AppleVTD::iovmInsert(ppnum_t addr, IOIte
 	STAT_ADD(fSpace, inserts, pageCount);
 }
 
+UInt32 AppleVTD::configRead16(UInt32 seg, UInt32 bus, UInt32 dev, UInt32 func, UInt32 off)
+{
+    IOACPIAddress address;
+    UInt64 value;
+    
+    address.pci.segment = seg;
+    address.pci.bus = bus;
+    address.pci.device = dev;
+    address.pci.function = func;
+    address.pci.offset = off;
+    address.pci.reserved = 0;
+    value = -1ULL;
+    
+    provider->readAddressSpace(&value, kIOACPIAddressSpaceIDPCIConfiguration, address, 16);
+    
+    return value;
+}
+
+bool AppleVTD::parse_dev_scope(const void *start, const void *end, UInt16 seg, UInt16 type)
+{
+    const ACPI_DMAR_DEVICE_SCOPE *scope;
+    ACPI_DMAR_PCI_PATH *path;
+    UInt16 vend;
+    int count = 0, fault = 0;
+    
+    while (start < end) {
+        scope = (typeof(scope)) start;
+        path = (typeof(path)) (scope + 1);
+        
+        if ( (scope->Length < MIN_SCOPE_LEN) ||
+            (scope->EntryType >= ACPI_DMAR_SCOPE_TYPE_RESERVED) ) {
+            IOPrint("Invalid device scope\n");
+            return false;
+        }
+        
+        if (scope->EntryType == ACPI_DMAR_SCOPE_TYPE_ENDPOINT) {
+            vend = configRead16(seg, scope->Bus, path->Device, path->Function, 0);
+            if ((vend == 0xffff) || (vend == 0x0000) || (vend == 0x00ff) || (vend == 0xff00)) {
+                IOPrint("Non-existent device %04x:%02x:%02x.%u is reported\n",
+                      seg, scope->Bus, path->Device, path->Function);
+                fault++;
+            } else
+            // disable IG unit
+            if (type == ACPI_DMAR_TYPE_HARDWARE_UNIT)
+                if ((seg == 0) && (scope->Bus == 0) && (path->Device == 2) && (path->Function == 0))
+                    return false;
+            count++;
+        }
+        
+        start = ((char *) start) + scope->Length;
+    }
+    
+    if (count == 0) {
+        /*if (!unit->global)
+            IOPrint("No devices found under the scope\n");*/
+        if (type == ACPI_DMAR_TYPE_RESERVED_MEMORY)
+            return false;
+    }
+    else if (count == fault) {
+        if (type == ACPI_DMAR_TYPE_HARDWARE_UNIT) {
+#if WA_BBUG
+            IOPrint("Workaround BIOS bug: ignore the unit due to all devices under it's scope aren't"
+              " PCI discoverable\n");
+            return false;
+#endif
+            ;
+        } else {
+            IOPrint("Ignore the reserved region due to all devices under it's scope aren't"
+                  " PCI discoverable\n");
+            return false;
+        }
+    }
+    
+    return true;
+}
+
+vtd_unit_t * AppleVTD::unit_init(ACPI_DMAR_HARDWARE_UNIT * dmar)
+{
+	vtd_unit_t * unit;
+    
+	unit = IONew(vtd_unit_t, 1);
+	if (!unit) return (NULL);
+	bzero(unit, sizeof(vtd_unit_t));
+    
+	unit->dmar = dmar;
+    
+	VTLOG("unit %p Address %llx, Flags %x\n",
+          dmar, dmar->Address, dmar->Flags);
+    
+	unit->regs = (typeof unit->regs) ml_io_map(dmar->Address, 0x1000);
+    
+    if (fs.qi && !((unit->regs->extended_capability >> 1) & 0x1))
+        fs.qi = false;
+    
+	uint32_t
+	offset = (unit->regs->extended_capability >> (8 - 4)) & (((1 << 10) - 1) << 4);
+	unit->iotlb = (typeof(unit->iotlb)) (((uintptr_t)unit->regs) + offset);
+    
+	offset = (unit->regs->capability >> (24 - 4)) & (((1 << 10) - 1) << 4);
+	unit->faults = (typeof(unit->faults)) (((uintptr_t)unit->regs) + offset);
+	unit->num_fault = (1 + ((unit->regs->capability >> 40) & ((1 << 8) - 1)));
+    
+	unit->selective = (1 & (unit->regs->capability >> 39));
+	unit->rounding = (0x3f & (unit->regs->capability >> 48));
+	unit->caching = (1 & (unit->regs->capability >> 7));
+	unit->global = (ACPI_DMAR_INCLUDE_ALL & dmar->Flags);
+    
+	VTLOG("cap 0x%llx extcap 0x%llx glob %d cache sel %d mode %d iotlb %p nfault[%d] %p\n",
+          unit->regs->capability, unit->regs->extended_capability,
+          unit->global, unit->selective, unit->caching,
+          unit->iotlb, unit->num_fault, unit->faults);
+
+	// caching is only allowed for VMs
+	if (unit->caching
+    || !parse_dev_scope((void *) (dmar + 1), ((char *) dmar) + dmar->Header.Length,
+            dmar->Segment, ACPI_DMAR_TYPE_HARDWARE_UNIT))
+	{
+        if (dmar->Segment == 0 && unit->global && !include_all_found)
+            include_all_found = true;
+        else {
+            IODelete(unit, vtd_unit_t, 1);
+            unit = NULL;
+            IOPrint("Unit destroyed\n");
+        }
+	}
+	
+	return (unit);
+}
+
 #endif /* ACPI_SUPPORT */
 
