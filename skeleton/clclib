// Written by Artem Falcon <lomka@gero.in>

class Expression; // Avoid non-declared type from tab.hpp

#include "parser.tab.hpp"

#include "headers.h"
#include "shared.h"
#include "lexer.h"

#include "AST.h"

extern std::deque <Expression *> tree;
extern std::string error_str;

#include "MemPool.h"

#include <string.h> // strcpy()

void ExeParser::compile(std::string str) {error_str="";tmp="";tree.clear();
                        source_str=str; ssci=source_str.begin();yyparse();}
void ExeParser::yyerror(const char *s) {
	error_str=("Error in source clause: ");
	error_str+=s; error_str.append(". Can't parse near: \"");
	error_str+=*(--ssci); error_str+='"';
}
int strtype(std::string str)
{
	std::string::iterator c; c = str.begin();
        int isnum = 0; int fpfl = 0;
        for(;c != str.end();c++) {
                if(isdigit(*c) && !fpfl) isnum = 'i';
                else if(isdigit(*c) && fpfl) ;
                else if(*c == '.' && c != str.end()
                && isdigit(*(++c))) {isnum = 'f'; fpfl++;}
                else if(*c != '-') {isnum = 's'; break;}
                if(fpfl > 1) {isnum = 's'; break;}
        }
	if(!isnum) return 's';
        return isnum;
}
inline float str2num(std::string s) {std::istringstream ss(s); float v; ss >> v; return v;}
inline bool my_alnum(char c) {return isalnum(c) || c == '_' || c == '.';}
int strlex(char a, char b) 
{
	if(a == '+' && b == '+') return INC;
	if(a == '-' && b == '-') return DEC;
	if(a == '<' && b == '<') return SL;
	if(a == '>' && b == '>') return SR;
	if(a == '<' && b == '=') return LE;
	if(a == '>' && b == '=') return BE;
	if(a == '=' && b == '=') return EE;
	if(a == '!' && b == '=') return NE;
	if(a == '&' && b == '&') return AND;
	if(a == '|' && b == '|') return OR;
	if(a == '.' && b == '.') return RA;
	if(a == '+' && b == '=') return SS;
	if(a == '-' && b == '=') return SV;
	if(a == '*' && b == '=') return SU;
	if(a == '/' && b == '=') return SD;
	if(a == '%' && b == '=') return SO;
	if(a == '&' && b == '=') return SAND;
	if(a == '^' && b == '=') return SXOR;
	if(a == '|' && b == '=') return SOR;
	return 0;
}
int strlex2(char a, char b, char c)
{
        if(a == 'i' && b == 'n' &&
        !my_alnum(c)) return IN;
	return 0;
}
bool tcast(std::string t){if(t == "int" || t == "float" || t == "string") return 1; return 0;}
int ExeParser::yylex(void *v)
{
	while(isspace(*ssci)) ssci++;
	if(ssci == source_str.end()) return (0);
	if(*ssci == '"') {ssci++; while(*ssci != '"') {tmp.push_back(*ssci); ssci++;}} // Const strings
	if(!tmp.empty()) {
		*(char **) v = Pool->allocate(tmp.length() + 1); strcpy( ((YYSTYPE *) v)->str, tmp.c_str());
		tmp=""; ssci++; return STR;
	}
        int c = strlex(*ssci, *(++ssci));
        if(!c) ssci--; else {ssci++; return c;}
        c = strlex2(*ssci, *(++ssci), *(++ssci));
        if(!c)  ssci-=2; else {ssci++; return c;}
	if(gram_letters.find(*ssci) != std::string::npos) { // Found grammar letter
		int c = *ssci;
		ssci++;
                return c; // Return it
        }
	while((ssci != source_str.end() || gram_letters.find(*ssci) == std::string::npos) &&
		my_alnum(*ssci)) { 	
		tmp.push_back(*ssci); // Append to buffer string
		ssci++;
	}

	if(!tmp.empty()) {
                *(char **) v = Pool->allocate(tmp.length() + 1);
                strcpy( ((YYSTYPE *) v)->str, tmp.c_str());
		if(tcast(tmp)) {tmp=""; return TYPE;}
                tmp="";
                return STR;
        }
#if 0
	int flag = 0; while(isspace(*ssci)) ssci++; // Assigenment state spaghetti
	if(ssci != source_str.end() && *ssci == '=') {
		if(!isspace(*ssci)) ssci++; while(isspace(*ssci)) ssci++;
		if(ssci != source_str.end() && gram_letters.find(*(++ssci))
		== std::string::npos && my_alnum(*ssci))
		while(*ssci != '=') ssci--;
		while(isspace(*ssci)) ssci--;
		if(gram_letters.find(*ssci) != std::string::npos) ssci--; 
		flag = 1;  
	}
	else if(ssci != source_str.end() && gram_letters.find(*ssci) != std::string::npos) {
		if(*(++ssci) == '=') {
                if(ssci != source_str.end() && gram_letters.find(*(++ssci))
                == std::string::npos && my_alnum(*ssci))
                while(*ssci != '=') ssci--;
                while(isspace(*ssci)) ssci--;
                if(gram_letters.find(*ssci) != std::string::npos) ssci--;
                flag = 1;
		}
		else ssci--;
	}
	if(!tmp.empty() && !flag) {
		Value val = t.get_field(tmp);
		if(val.get_type() == 'i') {
			tmp = num2str(*((int *) &val));;
                        *(char **) v = Pool->allocate(tmp.length() + 1);
                        strcpy( ((YYSTYPE *) v)->str, tmp.c_str());
			tmp="";
			return STR;
		}
		if(val.get_type() == 'f') {
			tmp = num2str(*((float *) &val));
			*(char **) v = Pool->allocate(tmp.length() + 1); 
			strcpy( ((YYSTYPE *) v)->str, tmp.c_str());
			tmp="";
			return STR;
		}
		if(val.get_type() == 's') {
			*(char **) v = Pool->allocate(tmp.length() + 1);
			strcpy( ((YYSTYPE *) v)->str, val.get_str().c_str());
			tmp="";
			return STR;
		}
		if(val.get_type() == 'e') 	
		{*(char **) v = Pool->allocate(tmp.length() + 1);
		strcpy( ((YYSTYPE *) v)->str, tmp.c_str());
		if(strtype(tmp) == 'i' || strtype(tmp) == 'f') {tmp="";return NUM;}
		else {if(tcast(tmp)) {tmp=""; return TYPE;} tmp=""; return STR;}}
	}
	else if(!tmp.empty() && flag) {
		*(char **) v = Pool->allocate(tmp.length() + 1);
		strcpy( ((YYSTYPE *) v)->str, tmp.c_str());
		tmp="";
		return STR;
	}
#endif
}
#if 0
char *ExeParser::set_func(char *arg)
{
	int t1 = strtype(arg);
	std::vector<Value> a;

	for(int i = 0; i < parms.size(); i++) {
		int t2 = strtype(parms[i]);
		//if(t2 != t1) {delete [] arg; delete [] pack;} // Should handle this error
		switch(t2) {
			case 'i': a.push_back((int) str2num(parms[i])); break;
			case 'f': a.push_back(str2num(parms[i])); break;
			case 's': a.push_back(parms[i]); break;
		}
	}
	parms.clear();
	
	int flag = 0;
	for(int i = 0; i < a.size(); i++) {
		if(t1 == 'i') {
			if((int) str2num(arg) == *((int *) &a[i])) {flag = 1; break;}
		}
		if(t1 == 'f') {
			if(str2num(arg) == *((float *) &a[i])) {flag = 1; break;}
		}
		if(t1 == 's') {
			if(arg == a[i].get_str()) {flag = 1; break;}
		}
	}
	char *rv = Pool->allocate(1);
        strcpy(rv, num2str(flag).c_str());

	//delete [] arg;
        return rv;
}

char *ExeParser::setr_func(char *arg, char *f_arg, char *s_arg)
{
	int t1 = strtype(arg), t2 = strtype(f_arg), 
	t3 = strtype(s_arg);
	//if(t1 != t2 && t1 != t3) {delete [] arg; delete [] f_arg; delete [] s_arg;} // ...Error
	int res = 'e';
	switch(t1) {
		case 'i': res = (int(str2num(arg)) >= int(str2num(f_arg)) && 
		int(str2num(arg)) <= int(str2num(s_arg))); break;
		case 'f': res = (str2num(arg) >= str2num(f_arg) &&
		str2num(arg) <= str2num(s_arg)); break;
		case 's': std::string a=arg, b=f_arg, s=s_arg; res = (a >= b && a <= s); break; 
	}
	//delete [] arg; delete [] f_arg; delete [] s_arg;
	char *rv = Pool->allocate(1);
	strcpy(rv, num2str(res).c_str()); return rv; 
}
#endif
Value ExeEval::exec(ExeObject *g, ExeObject *t)
{
	if(error_str != "")
		return "Can't execute due error in string given to compile. " +
			error_str;
        int i;
        for(i = 0; i < tree.size(); i++) {
                // Change values of leaves
                if(!tree[i]->is_what()) {
                        std::string str = tree[i]->get_value().get_str();
                        int type = strtype(str);
			// Not represent strings looks like numbers to ints,floats
			int not_convert = tree[i]->not_convert;
                        // Free memory allocated for leave, as we'll create new ones
                        // As nodes contain method that just refers on leaves, there is no
                        // need in manually sharping nodes
                        delete tree[i]; tree.erase(tree.begin() + i);

                        // If actually there are numbers, replace them
                        // by integers and floats
                        if(type == 'i' && not_convert == 0)
                                tree.insert(tree.begin() + i, new Operand((int) str2num(str), 0));
                        if(type == 'f' && not_convert == 0)
                                tree.insert(tree.begin() + i, new Operand((float) str2num(str), 0));
	
			// Fields
			if(type == 's') {
				Value f = t->get_field(str);
				if(f.get_type() != 'e' && tree[i+1]->is_what() != 'a'
							&& tree[i+1]->is_what() != 'b') // not asgn
					tree.insert(tree.begin() + i, new Operand(t->get_field(str), 0));
				// Not part of This
				 else tree.insert(tree.begin() + i, new Operand(str, 0) );
			}
                }
		// Function with no args
                if(tree[i]->is_what() == 'v') {
                        std::vector <Value> args; args.push_back(0);
			std::string s = tree[i-1]->get_value().get_str();
                        delete tree[i-1]; tree.erase(tree.begin() + (i-1));
                        tree.insert(tree.begin() + (i-1),
                                new Operand(g->do_call(s, args), 0) );
                }
		// Asgn
		if(tree[i]->is_what() == 'a') {
			std::string name = tree[i-2]->get_value().get_str();
			Value v = tree[i-1]->get_value();
			delete tree[i-2]; tree.erase(tree.begin() + (i-2));
			t->set_field(name, v);
			tree.insert(tree.begin() + (i-2), new Operand(t->get_field(name), 0)); 
		}
                // Asgn2
                if(tree[i]->is_what() == 'b') {
                        std::string name = tree[i-2]->get_value().get_str();
			Value v1 = t->get_field(name);
			int type = tree[i-2]->get_value().get_type();
			int type2 = tree[i-1]->get_value().get_type();
			int ty = type == type2 ? type : 0; 
                        Value v = tree[i-1]->get_value();
			Value res;
			switch(tree[i]->res()) { 
				case clc_o::O_SS: { if(ty == 'i') 
					t->set_field(name, res= *((int *) &v1) + *((int *) &v));
						if(ty == 'f')
					t->set_field(name, res= *((float *) &v1) + *((int *) &v));
						if(ty == 's')
					t->set_field(name, res= v1.get_str() + v.get_str());
				}
				break;
				case clc_o::O_SV: { if(ty == 'i') 
					t->set_field(name, res= *((int *) &v1) - *((int *) &v));
						if(ty == 'f')
					t->set_field(name, res= *((float *) &v1) - *((float *) &v));
				}
				break;
				case clc_o::O_SU: { if(ty == 'i') 
					t->set_field(name, res= *((int *) &v1) * *((int *) &v));
						if(ty == 'f')
					t->set_field(name, res= *((float *) &v1) * *((float *) &v)); 
				}
				break;
				case clc_o::O_SD: { if(ty == 'i') 
					t->set_field(name, res= *((int *) &v1) / *((int *) &v));
						if(ty == 'f')
					t->set_field(name, res= *((float *) &v1) / *((float *) &v)); 	
				}	
				break;
				if(ty == 'i') {
				case clc_o::O_SO: t->set_field(name,         
                                        res= *((int *) &v1) % *((int *) &v));
				break;
				case clc_o::O_SAND: t->set_field(name,         
                                        res= *((int *) &v1) & *((int *) &v));
				break;
				case clc_o::O_SXOR: t->set_field(name,         
                                        res= *((int *) &v1) ^ *((int *) &v));
				break;
				case clc_o::O_SOR: t->set_field(name,         
                                        res= *((int *) &v1) | *((int *) &v));
				break;
				}
			}
			delete tree[i-1]; tree.erase(tree.begin() + (i-1));
                        tree.insert(tree.begin() + (i-1), new Operand(t->get_field(name), 0));
                }
		// Function
		if(tree[i]->is_what() == 'f') {
			std::vector <Value> v; 
			std::deque<Expression*>::iterator it = tree.begin() + (i-1);
			int it2 = i-1;

			while(!tree[it2]->is_f_name) {
				if(tree[it2]->is_arg)
				v.push_back(tree[it2]->get_value());
				it--;it2--;
			}

			std::string s = tree[it2]->get_value().get_str(); // F name

			std::vector <Value> pv; for(int j = v.size()-1; j >= 0; j--) pv.push_back(v[j]); // invert
			v.clear();			

			g->do_call(s, pv).get_str(); // Anomaly

			delete tree[it2]; tree.erase(tree.begin() + (it2));
			tree.insert(tree.begin() + (it2), 
				new Operand( g->do_call(s, pv), 0 ));
			pv.clear();
		}
		// Set
		if(tree[i]->is_what() == 's') {
			std::vector <Value> v;
			std::deque<Expression*>::iterator it = tree.begin() + (i-1);
			int it2 = i-1; int j;

			while(!tree[it2]->is_f_name) {if(tree[it2]->is_arg)
			v.push_back(tree[it2]->get_value()); it--;it2--;}
			std::vector <Value> pv; for(j=v.size()-1;j>=0;j--)pv.push_back(v[j]);
			v.clear();
			Value inp = tree[it2]->get_value(); int type = tree[it2]->get_value().get_type();
		
			int flag = 0;
			for(j = 0; j < pv.size(); j++) {
				if(type == 'i') {
					if( *((int *) &inp) == *((int *) &pv[j]) ) {flag = 1; break;} 
				}
				if(type == 'f') {
					if(*((float *) &inp) == *((int *) &pv[j])) {flag = 1; break;}
				}
				if(type == 's') {
					if(inp.get_str() == pv[j].get_str()) {flag = 1; break;}
				}
			}
                        delete tree[it2]; tree.erase(tree.begin() + (it2));
                        tree.insert(tree.begin() + (it2),
                                new Operand(flag, 0));
			pv.clear();
		}
        }

        return tree[i-1]->get_value();

        // If nothing, prevent segfault so friends
        return 0;
}

