$dukzcry$
--- vbe.c.orig	2012-04-16 18:43:17.000000000 +0400
+++ vbe.c	2012-04-16 19:03:48.000000000 +0400
@@ -43,6 +43,7 @@ static int vbeverbose = 1;
 static struct _vbestate {
 	int		available;
 	int		modenum;
+	int		old_vbe;
 } vbestate;
 
 static void
@@ -58,20 +59,57 @@ vbe_dump(struct vbeinfoblock *vbe)
 }
 
 static int
-vbe_mode_is_supported(struct modeinfoblock *mi)
+vbe_mode_is_supported(struct modeinfoblock *mi, int vbeverbose, int retlin, int modenum)
 {
+	int ret = 0;
+	char *str = NULL;
+
 	if ((mi->ModeAttributes & 0x01) == 0)
-		return 0;	/* mode not supported by hardware */
-	if ((mi->ModeAttributes & 0x08) == 0)
-		return 0;	/* linear fb not available */
-	if ((mi->ModeAttributes & 0x10) == 0)
-		return 0;	/* text mode */
-	if (mi->NumberOfPlanes != 1)
-		return 0;	/* planar mode not supported */
+		ret = 0x01;
+	else if ((mi->ModeAttributes & 0x08) == 0)
+		ret = 0x08;
+	else if ((mi->ModeAttributes & 0x10) == 0)
+		ret = 0x10;
+	if (ret) {
+		if (vbeverbose) {
+			char string[] = "Mode not supported by hardware";
+			str = (char *) &string;
+			switch (ret) {
+				//case 0x01: ... break;
+				case 0x08:
+					//printf("Linear fb isn't"
+						//"available\n");
+					if (retlin)
+						return 0x08;
+				break;
+				case 0x10:
+					strncpy(str, "Text mode", sizeof(string));
+				break;
+			}
+		}
+		goto unsp;
+	}
+	if (mi->NumberOfPlanes != 1) {
+		if (vbeverbose) {
+			char string[] = "Planar mode isn't supported";
+			str = (char *) &string;
+		}
+		goto unsp;
+	}	
 	if (mi->MemoryModel != 0x04 /* Packed pixel */ &&
-	    mi->MemoryModel != 0x06 /* Direct Color */)
-		return 0;	/* unsupported pixel format */
+	    mi->MemoryModel != 0x06 /* Direct Color */) {
+		if (vbeverbose) {
+			char string[] = "Unsupported pixel format";
+			str = (char *) &string;
+		}
+		goto unsp;
+	}
 	return 1;
+unsp:
+	if (!retlin) {
+		printf("VESA VBE mode 0x%x is not supported.\n\t%s\n", modenum, str);
+	}
+	return 0;
 }
 
 void
@@ -93,6 +131,8 @@ vbe_init(void)
 	vbe_dump(&vbe);
 	vbestate.available = 1;
 	vbestate.modenum = 0;
+	if (vbe.VbeVersion == 0x102) /* VBE 1.2 */
+		vbestate.old_vbe = 1;
 }
 
 int
@@ -140,14 +180,25 @@ vbe_set_mode(int modenum)
 		return 1;
 	}
 
-	if (!vbe_mode_is_supported(&mi)) {
-		printf("VESA VBE mode 0x%x is not supported.\n", modenum);
+	if (!vbe_mode_is_supported(&mi, vbeverbose, 0, modenum))
 		return 1;
-	}
 
-	ret = biosvbe_set_mode(modenum);
+	//if (vbestate.old_vbe)
+		//vbe_lfb_quirks();
+
+	ret = biosvbe_set_mode(modenum | (vbestate.old_vbe ?
+		0 /* Found very old VBE version, lfb is rather not supported,
+		   * or can be activated via device regs */
+		: 0x4000));
 	if (ret != 0x004f) {
 		printf("VESA VBE mode 0x%x could not be set.\n", modenum);
+		if (vbeverbose) {
+			uint8_t ah = ret >> 8;
+			if (ah == 0x02)
+				printf("\tHardware doesn't support this func\n");
+			if (ah == 0x03)
+				printf("\tFunc call is invalid in current vmode\n");
+		}
 		return 1;
 	}
 
@@ -256,7 +307,7 @@ vbe_find_mode(char *str)
 		if (biosvbe_get_mode_info(mode, &mi) != 0x004f)
 			continue;
 		/* we only care about linear modes here */
-		if (vbe_mode_is_supported(&mi) == 0)
+		if (vbe_mode_is_supported(&mi, 0, 1, 0) == 0x08)
 			continue;
 		safety = 0;
 		if (mi.XResolution == x &&
@@ -265,7 +316,6 @@ vbe_find_mode(char *str)
 			return mode;
 	}
 
-	printf("VESA VBE BIOS does not support %s\n", str);
 	return 0;
 }
 
@@ -311,7 +361,7 @@ vbe_modelist(void)
 		if (biosvbe_get_mode_info(mode, &mi) != 0x004f)
 			continue;
 		/* we only care about linear modes here */
-		if (vbe_mode_is_supported(&mi) == 0)
+		if (vbe_mode_is_supported(&mi, 0, 1, 0) == 0x08)
 			continue;
 		safety = 0;
 		if (nmodes % 4 == 0)
--- biosvbe.S.orig	2009-02-17 01:39:30.000000000 +0300
+++ biosvbe.S	2012-04-11 20:55:51.000000000 +0400
@@ -147,7 +147,6 @@ ENTRY(biosvbe_set_mode)
 	push	%edi
 
 	movl	8(%ebp), %ebx	/* mode number */
-	orl	$0x4000, %ebx
 
 	call	_C_LABEL(prot_to_real)
 	.code16
