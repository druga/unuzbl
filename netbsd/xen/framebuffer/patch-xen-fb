$dukzcry$
--- /sys/arch/xen/include/xen.h.bak	2012-04-15 23:22:47.000000000 +0400
+++ /sys/arch/xen/include/xen.h	2012-04-16 00:24:29.000000000 +0400
@@ -45,6 +45,7 @@ union xen_cmdline_parseinfo {
 	struct xen_netinfo	xcp_netinfo;
 	char			xcp_console[16];
 	char			xcp_pcidevs[64];
+	char			xcp_framebuffer[10];
 };
 
 #define	XEN_PARSE_BOOTDEV	0
@@ -52,6 +53,7 @@ union xen_cmdline_parseinfo {
 #define	XEN_PARSE_CONSOLE	2
 #define	XEN_PARSE_BOOTFLAGS	3
 #define	XEN_PARSE_PCIBACK	4
+#define XEN_PARSE_FRAMEBUFFER	5
 
 void	xen_parse_cmdline(int, union xen_cmdline_parseinfo *);
 
--- /sys/arch/xen/xen/xen_machdep.c.bak	2012-04-15 23:19:04.000000000 +0400
+++ /sys/arch/xen/xen/xen_machdep.c	2012-04-16 02:48:01.000000000 +0400
@@ -201,6 +201,11 @@ xen_parse_cmdline(int what, union xen_cm
 				strncpy(xcp->xcp_pcidevs, opt + 13,
 				    sizeof(xcp->xcp_pcidevs));
 			break;
+		case XEN_PARSE_FRAMEBUFFER:
+			if (strncmp(opt, "_btinfo_framebuffer_ep=", 23) == 0)
+				strncpy(xcp->xcp_framebuffer, opt + 23,
+					sizeof(xcp->xcp_framebuffer));
+			break;
 		}
 
 		if (cmd_line)

Based on the code of Jared D. McNeill <jmcneill@invisible.ca>

#+++ /sys/arch/x86/x86/x86_autoconf.c 2012-04-12 18:03:38.000000000 +0400
--- autoconf.c.bak	2012-04-12 16:56:49.000000000 +0400
+++ /sys/arch/xen/x86/autoconf.c	2012-04-16 21:35:43.000000000 +0400
@@ -89,9 +89,16 @@ __KERNEL_RCSID(0, "$NetBSD: autoconf.c,v
 #include <machine/gdt.h>
 #include <machine/pcb.h>
 #include <machine/bootinfo.h>
+#include <machine/pio.h>
 
 static void findroot(void);
 static int is_valid_disk(device_t);
+
+#include "pci.h"
+
+#if NPCI > 0
+static void x86_genfb_set_mapreg(void *, int, int, int, int);
+#endif
 static void handle_wedges(device_t, int);
 
 struct disklist *x86_alldisks;
@@ -217,13 +224,14 @@ findroot(void)
 	}
 }
 
-#include "pci.h"
-
 #include <dev/isa/isavar.h>
 #if NPCI > 0
 #include <dev/pci/pcivar.h>
 #endif
+#include <dev/wsfb/genfbvar.h>
+#include <dev/ic/vgareg.h>
 
+struct genfb_colormap_callback gfb_cb;
 
 #if defined(NFS_BOOT_BOOTSTATIC) && defined(DOM0OPS)
 static int
@@ -273,6 +281,10 @@ dom0_bootstatic_callback(struct nfs_disk
 void
 device_register(device_t dev, void *aux)
 {
+#if NPCI > 0
+	static bool found_console = false;
+#endif
+
 	/*
 	 * Handle network interfaces here, the attachment information is
 	 * not available driver independently later.
@@ -342,6 +354,48 @@ device_register(device_t dev, void *aux)
 		}
 #endif
 	}
+#if NPCI > 0
+	if (device_parent(dev) && device_is_a(device_parent(dev), "pci") &&
+		found_console == false) {
+			struct btinfo_framebuffer *fbinfo;
+			struct pci_attach_args *pa = aux;
+			prop_dictionary_t dict;
+			union xen_cmdline_parseinfo xcp;
+
+			xen_parse_cmdline(XEN_PARSE_FRAMEBUFFER, &xcp);
+			bootinfo.bi_data[bootinfo.bi_nentries++] =
+				strtoul((const char *)
+				&xcp.xcp_framebuffer, NULL, 16);
+
+			if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY) {
+				fbinfo = lookup_bootinfo(BTINFO_FRAMEBUFFER);
+				if (fbinfo == NULL || fbinfo->physaddr == 0)
+					return;
+				fbinfo->vbe_commit();
+				dict = device_properties(dev);
+				prop_dictionary_set_uint32(dict, "width",
+					fbinfo->width);
+				prop_dictionary_set_uint32(dict, "height",
+					 fbinfo->height);
+				prop_dictionary_set_uint8(dict, "depth",
+					 fbinfo->depth);
+				prop_dictionary_set_uint64(dict, "address",
+					 fbinfo->physaddr);	
+				prop_dictionary_set_uint16(dict, "linebytes",
+					 fbinfo->stride);
+				prop_dictionary_set_bool(dict, "is_console", true);
+
+				if (fbinfo->depth == 8) {
+					gfb_cb.gcc_cookie = NULL;
+					gfb_cb.gcc_set_mapreg = x86_genfb_set_mapreg;
+					prop_dictionary_set_uint64(dict,
+						"cmap_callback", (uint64_t)&gfb_cb);
+				}
+				found_console = true;
+				return;
+			}
+	}
+#endif
 	return;
 
 found:
@@ -354,6 +408,17 @@ found:
 	booted_device = dev;
 }
 
+#if NPCI > 0
+static void
+x86_genfb_set_mapreg(void *opaque, int index, int r, int g, int b)
+{
+	outb(0x3c0 + VGA_DAC_ADDRW, index);
+	outb(0x3c0 + VGA_DAC_PALETTE, (uint8_t)r >> 2);
+	outb(0x3c0 + VGA_DAC_PALETTE, (uint8_t)g >> 2);
+	outb(0x3c0 + VGA_DAC_PALETTE, (uint8_t)b >> 2);
+}
+#endif
+
 static void
 handle_wedges(device_t dv, int par)
 {
--- bootinfo.h.bak	2012-04-16 21:24:13.000000000 +0400
+++ /sys/arch/x86/include/bootinfo.h	2012-04-22 20:29:54.000000000 +0400
@@ -166,7 +166,7 @@ struct btinfo_biosgeom {
 };
 
 struct bi_modulelist_entry {
-	char path[80];
+	char path[160];
 	int type;
 	int len;
 	uint32_t base;
@@ -195,7 +195,10 @@ struct btinfo_framebuffer {
 	uint8_t rpos;
 	uint8_t gpos;
 	uint8_t bpos;
-	uint8_t reserved[16];
+	union {
+		int (*vbe_commit)(void);
+		uint8_t reserved[16];
+	};
 };
 
 #endif /* _LOCORE */
--- exec.c.bak	2012-04-16 21:06:22.000000000 +0400
+++ /sys/arch/i386/stand/lib/exec.c	2012-04-23 18:07:22.000000000 +0400
@@ -133,7 +133,7 @@ boot_module_t *boot_modules;
 bool boot_modules_enabled = true;
 bool kernel_loaded;
 
-static struct btinfo_framebuffer btinfo_framebuffer;
+struct btinfo_framebuffer btinfo_framebuffer;
 
 static struct btinfo_modulelist *btinfo_modulelist;
 static size_t btinfo_modulelist_size;
@@ -510,7 +510,24 @@ module_init(const char *kernel_path)
 			btinfo_modulelist->num++;
 			bi = (struct bi_modulelist_entry *)(buf + off);
 			off += sizeof(struct bi_modulelist_entry);
-			strncpy(bi->path, bm->bm_path, sizeof(bi->path) - 1);
+
+			char *ptr;
+			if ( (ptr = strstr(bm->bm_path, "netbsd")) &&
+				strstr(ptr, "XEN") ) {
+				btinfo_framebuffer.vbe_commit = vbe_commit;
+				((struct btinfo_common *) &btinfo_framebuffer)->len =
+					sizeof(struct btinfo_framebuffer);
+				((struct btinfo_common *) &btinfo_framebuffer)->type =
+					BTINFO_FRAMEBUFFER;
+				/* to-do: find a sane way to pass fb params to the
+				 * kernel, not forgetting that i can't reimplement
+				 * MIS */
+				snprintf(bi->path, sizeof(bi->path) - 1,
+					"%s _btinfo_framebuffer_ep=0x%lx", bm->bm_path,
+					vtophys((struct btinfo_common *) &btinfo_framebuffer));
+			}
+			else
+				strncpy(bi->path, bm->bm_path, sizeof(bi->path) - 1);
 			bi->base = image_end;
 			bi->len = len;
 			bi->type = BI_MODULE_ELF;
