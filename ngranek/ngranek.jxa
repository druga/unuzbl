;; Written by A. V. Lukyanov <lomka@gero.in>

; What i do here is basically a set of following steps:
; 1) Build a tree of segments which will be used for obtaining of fixed X ordinates independently of a projection plane rotate position, every PP segment gets an index from 0 to N;
; 2) Start parallel processing of faces for futher scene drawing, we handle only terminal dots. We get intersections with PP and obtain proper X'es by searching in 1), while Y's are calculated as on the distance of a perpendecular from a dot to PP. We create pairs of dots for the each end, since we're moving into pseudo-3D space. Here we collect these given dots into a new tree which is now a scene composition;
; 3) Traverse a tree from 2) and draw the elements. That's all.

(ns ngranek-data
    (use
     ; old style
     (joxa-records :only (defrecord+/2)) (joxa-core :only (define/2))))

(define crimson '[220 20 60])
(define purple '[128 0 128])

;(define unmellow '[255 255 120])
;(define lime '[50 205 50])

;(define baby '[137 207 240])
;(define cadet '[29 41 81])

(defrecord+ :data
  {screen (800 . 600)}
  ; hd = our, tl = focal lens positions
  {pov ((0 . 40) . (0 . 10))}
  {step 20}
  ; 2d figures
  {objs [((purple) . [((240 . -70) . (0 . -20)) ((0 . -240) . (-240 . -70))])
              ((crimson) . [((0 . -20) . (-240 . -70)) ((240 . -70) . (0 . -240))])]})

(ns ngranek
    (require (wxFrame :as wxframe) (wxWindow :as wxwindow)
	     (wxMenu :as wxmenu) (wxMenuBar :as wxbar)
	     (wxStatusBar :as wxstatbar) (wxGLCanvas :as wxglcanvas)
	     (gb_trees :joxify) (io_lib :joxify)
	     ngranek-data erlang gl glu wx joxa-lists)
    (use io erlang joxa-core math lists))

(define zero '(0 . 0))

;; helpers
; incr/decr are broken in joxa compiler
(defn incf (n)
  (erlang/+ n 1))

(defn decf (n)
  (erlang/- n 1))
;

(defn unfold (elm pred add inc acc idx)
  (if (pred elm)
     (unfold (inc elm) pred add inc (add elm acc idx) (incf idx))
    acc))

(defn unfold (empty beg pred add inc)
  (unfold beg pred add inc empty 1))

(defmacro andalso (x y)
  `(if ~x ~y :false))

(defn failed? (f)
  (== f []))

;; vector algebra
(defn dot-product (v1 v2)
	(erlang/+ (* (hd v1) (hd v2)) (* (tl v1) (tl v2))))

(defn vec-len (v)
	(sqrt (dot-product v v)))

; normalize to skip some extra calcs
(defn vec-norm (v)
  (let* (len (vec-len v))
     ((:'/' (hd v) len) . (:'/' (tl v) len))))

(defn vec-perp (v)
     ((tl v) . (erlang/- (hd v))))

(defmacro vec-op (op v2 v1)
  `((~op (hd ~v2) (hd ~v1)) . (~op (tl ~v2) (tl ~v1))))

(defn vec-scal-mul (v n)
  ((* (hd v) n) . (* (tl v) n)))

(defn vec-rot (v d an) (let ((x . y) v (px . py) d
        can (cos an) san (sin an)
	(x-px . y-py) (vec-op erlang/- v d))
    ((erlang/+ px (erlang/- (* x-px can) (* y-py san))) .
     (erlang/+ py (erlang/+ (* y-py can) (* x-px san))))))

(defn vec-angle (v1 v2)
  (acos (dot-product v1 v2)))

(defn vec-collinear? (v1 v2)
  (gte (dot-product v1 v2) 0))

;; gb_trees fun replacements
; intervals support
(defn tree-bounds (dir)
  (if (> dir 0)
       (fn (x y z) (let* (key-match (gte y x))
		     ((and key-match (< y z)) . key-match)))
	   (fn (x y z) (let* (key-match (lte y x))
			 ((and key-match (> y z)) . (not key-match))))))

(defn get-1 (key bounds tree)
  (if (== tree :nil)
      []
  (let ({key1 (end . val) left right} tree
	(bounded? . border) (bounds key1 key end))
    (if bounded?
	val
      (get-1 key bounds (if border right left))))))

(defn get (key dir tree)
  (get-1 key (tree-bounds dir) (element 2 tree)))

; key originating
(defn enter (key val tree) (let ((k . i) key)
    (if (gb-trees/is-defined key tree)
	(enter (k . (incf i)) val tree)
      (gb-trees/insert key val tree))))
;;

(defn dir-bound (dir end)
  (if (> dir 0)
       (fn (x) (lte x end))
     (fn (x) (gte x end))))

(defn dir-bounds (dir)
  (if (> dir 0)
       (fn (x y z) (and (> y x) (< y z)))
     (fn (x y z) (and (< y x) (> y z)))))

(defn dot-access (x)
  (if (== x 0)
       (fn (dot) (tl dot))
     (fn (dot) (hd dot))))

(defn get-side-dots (pov-end ppn hwidth)
  (let* (ppv (vec-scal-mul ppn hwidth))
    ((vec-op erlang/- pov-end ppv) . (vec-op erlang/+ pov-end ppv))))

(defn get-sides (pov-beg side-dots)
    ((vec-op erlang/- (hd side-dots) pov-beg) . (vec-op erlang/- (tl side-dots) pov-beg)))

; precision sensitive
(defn get-yf (v1 d1 v2 d2) (let* (v1-x (hd v1))
    (if (== v1-x 0)
	(get-yf v2 d2 v1 d1)
      ; canonical line equation
      (fn (x) (erlang/+ (:'/' (* (tl v1) (erlang/- x (hd d1)))
			     v1-x)
		       (tl d1))))))

(defn get-intersect (v1 d1 v2 d2) (let (v1-x (hd v1) v2-x (hd v2)
		p2p3 (* (tl v1) v2-x) p1p4 (* v1-x (tl v2)))
      ; x extracted from equation system
      (:'/' (erlang/+ (erlang/- (* (* v1-x v2-x) (erlang/- (tl d2) (tl d1))) (* p1p4 (hd d2)))
		      (* p2p3 (hd d1)))
	    (erlang/- p2p3 p1p4))))
;

(defn find-intersect (beg end pov-beg side)
  (let* (; we need a new direction
	  vface (vec-op erlang/- end beg)
		x (get-intersect vface beg side pov-beg) dot (x . ((get-yf side pov-beg vface beg) x))
		access (dot-access (hd vface)))
     ; between A & B
     (if (and ((dir-bounds (access vface)) (access beg) (access dot) (access end))
	      ; sitting on the face is not an intersect
	      (not (== dot pov-beg)))
	 dot
       [])))

(defn choose-intersect (beg end pov-beg side1 side2)
  (let* (intersect (find-intersect beg end pov-beg side1))
     (if (failed? intersect)
	 ((find-intersect beg end pov-beg side2) . side2)
       (intersect . side1))))

(defn get-vpnf (pv ppv pov-end)
  ; vec who's normal to the plane
  (fn (dot) (let* (pp-x (get-intersect pv dot ppv pov-end))
	      (vec-op erlang/- dot (pp-x . ((get-yf ppv pov-end pv dot) pp-x))))))

(defn gen-faces (begs ends color pvs pov heights tree acs)
  ; to-do: fixup
  (if (== (hd ends) [])
      (do (format "Intersect botch~n")
	  [])
  (let ((beg . begv) begs (end . endv) ends (pv . ppv) pvs (pov-beg . pov-end) pov (height . hheight) heights (access . access-ppn) acs
	; gives ok perspective
	vpnf (get-vpnf pv ppv pov-end) begvpn (vpnf beg) endvpn (vpnf end))
    ; omit inside pov objs
    ; to-do: rework skipping of too far objs, shouldn't be that way depended on win height 
    (if (and (< (vec-len begv) hheight) (vec-collinear? begvpn pv)
		  (< (vec-len endv) hheight) (vec-collinear? endvpn pv))

  (let* (beg-x (get-intersect begv pov-beg ppv pov-end) end-x (get-intersect endv pov-beg ppv pov-end)
	beg-dot (beg-x . ((get-yf ppv pov-end begv pov-beg) beg-x)) end-dot (end-x . ((get-yf ppv pov-end endv pov-beg) end-x))
	pp-beg (get (access beg-dot) access-ppn tree) pp-end (get (access end-dot) access-ppn tree))
    (when (== pp-beg [])
      (format "beg ~p not in [~p:~p]~n" [(access beg-dot) (gb-trees/smallest tree) (gb-trees/largest tree)]))
    (when (== pp-end [])
      (format "end ~p not in [~p:~p]~n" [(access end-dot) (gb-trees/smallest tree) (gb-trees/largest tree)]))
    (if (or (== pp-beg []) (== pp-end []))
	[]

    ; omit lines (a-x = b-x)
    ;(if (!= pp-beg pp-end)
    
  (let* (fl-beg-len (vec-len begvpn) fl-end-len (vec-len endvpn)
	 h-beg (erlang/- height fl-beg-len) h-end (erlang/- height fl-end-len))
    ;(format "~p" [(beg . end)])
    ; we use middle point of face
       [(:'/' (erlang/+ h-beg h-end) 2)
	; integerize neglecting precision
	color (pp-beg . (trunc fl-beg-len)) (pp-beg . (trunc h-beg)) (pp-end . (trunc h-end)) (pp-end . (trunc fl-end-len))])

		 ;[])
  ))

  ;(do (format "~p too far~n" [(beg . end)])
      [];)
    ))))

(defn faces (line color pns tree acs sides pov hfov heights parent) (let ((beg . end) line (side1 . side2) sides pov-beg (hd pov) pn (hd pns)
      begv (vec-op erlang/- beg pov-beg) endv (vec-op erlang/- end pov-beg))
(send parent
  ; don't trash when going thru the face
  (if (or (== begv (zero)) (== endv (zero)))
      []
  (if (lte (vec-angle (vec-norm begv) pn) hfov)

      (if (lte (vec-angle (vec-norm endv) pn) hfov)
	  ; whole face
	  (gen-faces (beg . begv) (end . endv) color pns pov heights tree acs)
	; A + face part
	(gen-faces (beg . begv) (choose-intersect beg end pov-beg side1 side2) color pns pov heights tree acs))

    (if (lte (vec-angle (vec-norm endv) pn) hfov)
	; B + face part
	(gen-faces (end . endv) (choose-intersect beg end pov-beg side1 side2) color pns pov heights tree acs)
      (let* (intersect1 (find-intersect beg end pov-beg side1))
	; to-do: bump hfov a bit to deal with inexactness
	(if (andalso (not (failed? intersect1)) (lte (vec-angle (vec-norm (vec-op erlang/- intersect1 pov-beg)) pn) hfov))
	    (let* (intersect2 (find-intersect beg end pov-beg side2))
	      (if (andalso (not (failed? intersect2)) (lte (vec-angle (vec-norm (vec-op erlang/- intersect2 pov-beg)) pn) hfov))
		  ; face is bigger than fov
		  (gen-faces (intersect1 . side1) (intersect2 . side2) color pns pov heights tree acs)
		; face is not in fov
		[]))
	      []))
      ;
))))))

(defn figures-handler (list tree fun procs)
  (receive
   (after 0
	  (if (== procs 0)
	       tree
	      (if (!= list [])
		    (do (spawn (fn () (fun (hd list))))
			(figures-handler (tl list) tree fun procs))
		(figures-handler list tree fun procs))))
   ([]
    (figures-handler list tree fun (decf procs)))
   ((key . data)
    (figures-handler list (enter (key . 0) data tree) fun (decf procs)))
   (_
    (figures-handler list tree fun procs))))

(defn plane-proj (objs pns side-dots sides pov hfov heights parent) (let (ppn (tl pns)
		access (dot-access (hd ppn)) access-ppn (access ppn)
		inc (fn (seg) (erlang/+ seg access-ppn))
		; to-do: unwind a bit more to smash inexactness
		beg (erlang/- (access (hd side-dots)) access-ppn) end (inc (access (tl side-dots)))
	        less? (dir-bound access-ppn end))
    ; process faces in parallel
    (figures-handler objs (gb-trees/empty)
		     (fn (face) (faces (hd face) (tl face) pns
				    ; build segments tree of proj plane
				    (unfold
				     (gb-trees/empty)
				     (beg . (inc beg))
				     (fn (seg) (less? (tl seg)))
				     (fn (seg tree idx) (gb-trees/insert (hd seg) ((tl seg) . idx) tree))
				     (fn (seg) (let* (end (tl seg))
						(end . (inc end)))))
				    (access . access-ppn) sides pov hfov heights parent))
		     (length objs))))

(defn draw-canvas (iter tree color)
  (case (gb-trees/next iter)
    ({_ (color2 . dots) iter2}
  (gl/begin 7) ; GL_QUADS
  (when (!= color color2)
    (erlang/apply :gl :color3ub color2))
  (joxa-lists/dolist ((beg . end) dots) (gl/vertex2i beg end))
  (gl/end)
  (draw-canvas iter2 tree color2))
    (:none
     [])))

(defn render-scene (canvas objs pov pns sides side-dots hfov heights parent)
 (let* (tree (plane-proj objs pns side-dots sides pov hfov heights parent))
  (gl/clear 16384) ; GL_COLOR_BUFFER_BIT
  (draw-canvas (gb-trees/iterator tree) tree [])
  ;(format "Drawn ~w faces~n" [(element 1 tree)])
  (wxglcanvas/swapBuffers canvas)
  ;(let (0 (gl/getError))
  ))

(defn recalc-plane (pov hwidth) (let ((beg . end) pov
  pn (vec-norm (vec-op erlang/- end beg)) ppn (vec-perp pn)
  side-dots (get-side-dots end ppn hwidth))
  [(pn . ppn) side-dots (get-sides beg side-dots)]))

(defn event-handler (canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul)
  (receive
   (after 200
	  (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul))
   ({:wx _ _ _ {:wxKey :key_down _ _ key _ _ _ _ _ _ _ _}}
    (case key
      ; forward or backward
      (_ (when (or (== key 87) (== key 83)))

	 (let* (inc (if (== key 87) (fn (x y) (erlang/+ x y)) (fn (x y) (erlang/- x y))) pov-end (vec-op inc (tl pov) step-mul)
		    pov-new ((vec-op inc (hd pov) step-mul) . pov-end) side-dots-new (get-side-dots pov-end (tl pns) hwidth))

	   (wxframe/setStatusText frame (io-lib/format "POV: ~p" [pov-new]))
	   (render-scene canvas objs pov-new pns sides side-dots-new hfov heights parent)
	   (event-handler canvas parent steps frame objs pov-new pns sides side-dots-new hfov hwidth heights step-mul)))
      ; turn around
      (_ (when (or (== key 65) (== key 68)))

	 (let (pov-beg (hd pov) pov-new (pov-beg . (vec-rot (tl pov) pov-beg (if (== key 65) (tl steps) (erlang/- (tl steps)))))
		       [pns-new side-dots-new sides-new] (recalc-plane pov-new hwidth))

	   (wxframe/setStatusText frame (io-lib/format "POV: ~p" [pov-new]))
	   (render-scene canvas objs pov-new pns-new sides-new side-dots-new hfov heights parent)
	   (event-handler canvas parent steps frame objs pov-new pns-new sides-new side-dots-new hfov hwidth heights (vec-scal-mul (hd pns-new) (hd steps)))))
      (_
       (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul))))
   ({:wx _ _ _ {:wxSize :size {width height} _}}
    ; to-do: if only height or either width got changed, do just relevant recalcs
    (let* (hwidth-new (div width 2) side-dots-new (get-side-dots (tl pov) (tl pns) hwidth-new) sides-new (get-sides (hd pov) side-dots-new)
		       hfov-new (vec-angle (vec-norm (hd sides-new)) (hd pns)) heights-new (height . (div height 2)))

      (gl/loadIdentity)
      (gl/viewport 0 0 width height) (glu/ortho2D 0 width 0 height)
      (render-scene canvas objs pov pns sides-new side-dots-new hfov-new heights-new parent)
      (event-handler canvas parent steps frame objs pov pns sides-new side-dots-new hfov-new hwidth-new heights-new step-mul)))
   ({:wx _ _ _ {:wxClose :close_window}}
    :ok)
   ({:wx 10 _ _ _}
    (wxwindow/close frame)
    :ok)
   ;({'_wxe_error_' _ _}
    ;:fail)
   ({:ngranek cmd}
    (case cmd
      (:pov
       (format "You're ~p~n" [pov]))
      (:objs
       (format "~p~n" [objs]))
      (_
       []))
    (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul))
   ({:ngranek :pov pov-new}
    (case pov-new
      (((zero) . (zero))
       (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul))
      (((x1 . y1) . (x2 . y2)) (when (and (is_number x1) (is_number y1) (is_number x2) (is_number y2)))
       (let ([pns-new side-dots-new sides-new] (recalc-plane pov-new hwidth))
	 (wxframe/setStatusText frame (io-lib/format "POV: ~p" [pov-new]))
	 (render-scene canvas objs pov-new pns-new sides-new side-dots-new hfov heights parent)
	 (event-handler canvas parent steps frame objs pov-new pns-new sides-new side-dots-new hfov hwidth heights (vec-scal-mul (hd pns-new) (hd steps)))))
      (_
       (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul))))
   ({:ngranek :objs new-objs}
    (case new-objs
      (_ (when (is_list new-objs))
	 (if (all (fn (elm) (case elm
			      ((((= (x1 . y1) beg) . (= (x2 . y2) end)) . [r g b]) (when (and (is_number x1) (is_number y1) (is_number x2) (is_number y2)
										      (is_integer r) (is_integer g) (is_integer b)))
			       ; no vector, no face!
			       (!= (vec-op erlang/- end beg) (zero)))
			      (_
			       :false)))
		  new-objs)
	     (do (render-scene canvas new-objs pov pns sides side-dots hfov heights parent)
		 (event-handler canvas parent steps frame new-objs pov pns sides side-dots hfov hwidth heights step-mul))
	   (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul)))
      (_
       (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul))))
   (event
    ;(format "Received ~p~n" [event])
    (event-handler canvas parent steps frame objs pov pns sides side-dots hfov hwidth heights step-mul))))

(defn+ start ()
  (let (data (ngranek-data/make-fields []) (width . _height) (ngranek-data/screen data)
	     frame (wxframe/new (wx/new) 1 "ngranek raycaster by dukzcry" [{:size {width _height}}]) bar (wxbar/new)
	     statbar (wxframe/createStatusBar frame [{:number 1}]) height (element 2 (wxwindow/getClientSize frame))
	     menu (wxmenu/new) canvas (wxglcanvas/new frame)
	     pov (ngranek-data/pov data) step (ngranek-data/step data)
	     heights (height . (div height 2)) hwidth (div width 2)
	     [(= (pn . _) pns) side-dots sides] (recalc-plane pov hwidth) hfov (vec-angle (vec-norm (hd sides)) pn)
	     parent (self)
	   ; assign colors
	   objs (flatmap (fn (item) (let* (color (hd item))
				      (joxa-lists/map (face (tl item)) (face . color))))
			 (ngranek-data/objs data)))
    (wxframe/connect frame :close_window) (wxframe/connect frame :command_menu_selected) (wxframe/setMenuBar frame bar)
    ;(wxstatbar/setStatusWidths statbar [-1 150])
    (wxbar/append bar menu "&File")
    (wxmenu/append menu 10 "Exit")
    (wxwindow/show frame)
    (wxwindow/connect canvas :size) (wxwindow/connect canvas :key_down)
    (wxglcanvas/setCurrent canvas)
    (gl/viewport 0 0 width height) (glu/ortho2D 0 width 0 height)

    (wxframe/setStatusText frame (io-lib/format "POV: ~p" [pov]))
    (render-scene canvas objs pov pns sides side-dots hfov heights parent)
    
    (event-handler canvas parent (step . (* step 0.01)) frame objs pov pns sides side-dots hfov hwidth heights (vec-scal-mul pn step))
    ;(wx/destroy)
))
