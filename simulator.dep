/*:- op(501,xfx,my_is).
:- initialization(arithmetic_function(...)).

% xxx: YAP
:- dynamic(register_arithmetic/1).
arithmetic_function(Functor/Arity) :-
	retractall(register_arithmetic(Functor/Arity)),
	assertz(register_arithmetic(Functor/Arity)).
my_is(Result,Term) :-
	Term =.. [F|Args],
	eval_arith2(Args,Args2),
	((length(Args2,L),
	register_arithmetic(F/L),
	my_append(Args2, [Result], Args3),
	ATermN =.. [F|Args3],
	ATermN, !)
	; 
	(ATerm =.. [F|Args2], 
		Result = ATerm
	)), !.
eval_arith2([],[]). 
eval_arith2([Term|Rest],[TermResult|RestResult]) :-
	my_is(TermResult,Term),
	eval_arith2(Rest, RestResult).*/

%:- use_module(library(apply)).
% my_foldl(+#,+M,+u,-R)
my_foldl(T,[X|Xs],A,R) :-
	call(T,X,A,A1),
	my_foldl(T,Xs,A1,R), !. % next
my_foldl(_,[],R,R).

my_plus(X,Y,Z) :-
	Z is X + Y.
my_append(A,B,L) :-
	% DCG pokery
	expand_term(o --> A,X), arg(1,X,Y), arg(1,Y,Z), arg(2,Y,W),
	append_diff(Z-W,B-_,L-[]).
append_diff(A-B,B-C,A-C).
